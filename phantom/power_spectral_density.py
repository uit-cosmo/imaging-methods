import numpy as np
from scipy import signal
from scipy.optimize import minimize, differential_evolution, curve_fit
import matplotlib.pyplot as plt
import closedexpressions as ce
import warnings
from blobmodel import BlobShapeEnum
from enum import Enum
import fppanalysis as fppa


class AnalyticalExpressions(Enum):
    OneSided = 1
    TwoSided = 2


analytical_expressions = {
    AnalyticalExpressions.OneSided: ce.psd,
    AnalyticalExpressions.TwoSided: ce.psd,
}


class DurationTimeEstimator():
    def __init__(self, statistic, obj_fun):
        self.statistic = statistic
        self.obj_fun = obj_fun

    def estimate_duration_time(self, data_series, dt, nperseg, cutoff_freq):
        bounds = [(1e-2, 10), (0, 10)]

        if self.statistic == "psd":
            freqs, psd = signal.welch(data_series, fs=1 / dt, nperseg=nperseg)
            freqs = 2 * np.pi * freqs  # Convert to angular frequency (rad/s)

            mask = freqs < cutoff_freq
            result = minimize(
                lambda params: self._obj_fun_psd_two_sided(params, freqs[mask], psd[mask]),
                x0=[1, 1],
                method="Nelder-Mead",
                bounds=bounds,
                options={"maxiter": 1000},
            )

            if not result.success:
                warnings.warn(f"Optimization did not converge: {result.message}")
        if self.statistic == "acf":
            acf_times, acf = fppa.corr_fun(data_series, data_series, dt)
            mask = np.abs(acf_times) < 100

            result = minimize(
                lambda params: self._obj_fun_acf_two_sided(params, acf_times[mask], acf[mask]),
                x0=[1, 1],
                method="Nelder-Mead",
                bounds=bounds,
                options={"maxiter": 1000},
            )

        # Check optimization convergence
        if not result.success:
            warnings.warn(f"Optimization did not converge: {result.message}")

        taud, lamda = result.x
        fitted_lambda = 1 / (1 + lamda**2)
        return taud, fitted_lambda

    def _obj_fun_psd_two_sided(self, params, freqs, expected):
        lam = 1 / (1 + params[1] ** 2)
        return np.sum((ce.psd(freqs, params[0], lam) - expected) ** 2)

    def _obj_fun_acf_two_sided(self, params, times, expected):
        lam = 1 / (1 + params[1] ** 2)
        return np.sum((ce.acorr(times, params[0], lam) - expected) ** 2)

    def _obj_fun_psd_one_sided(self, taud, freqs, expected):
        return np.sum((ce.psd(freqs, taud, 0) - expected) ** 2)


def fit_psd(
    data_series, dt=None, nperseg=None, cutoff_freq=1e8, ax=None, relative=True, expression="two_sided"
):
    """
    Compute the power spectral density (PSD) of a data series using Welch's method,
    fit an analytical model derived from a Filtered Poisson Process (FPP) with
    two-sided exponential pulses, and optionally plot results.

    The analytical model for the PSD is:

    .. math::
        S(\omega) = \frac{2 \tau_d}{(1 + (1 - \lambda)^2 (\tau_d \omega)^2)(1 + (\lambda \tau_d \omega)^2)}

    where :math:`\omega` is the angular frequency (rad/s), :math:`\tau_d` is the duration time
    parameter, and :math:`\lambda \in [0, 1]` is the pulse function assymetry parameter.
    This model arises from the FPP model, where the signal is
    generated by a Poisson process filtered with two-sided exponential pulses, resulting
    in a Lorentzian-like PSD with two characteristic timescales.

    Parameters:
    -----------
    data_series : array-like
        Input time series data (1D).
    dt : float, optional
        Time step of the data series. If None, assumed to be 1.
    nperseg : int, optional
        Number of points per segment for Welch's method. If None, set to min(len(data_series) // 2, 10**4).
    cutoff_freq : float, optional
        Frequency cutoff for fitting (default: 1e8 rad/s).
    ax : matplotlib.axes.Axes, optional
        Axes object for plotting. If None, no plot is generated.
    relative : bool, if True the relative mean square error is minimized otherwise absolute error.

    Returns:
    --------
    taud : float
        Fitted decay time parameter.
    lam : float
        Fitted lambda parameter (in [0, 1]).
    """
    # Input validation
    data_series = np.asarray(data_series)
    if data_series.ndim != 1 or len(data_series) < 2:
        raise ValueError("data_series must be a 1D array with at least 2 points")
    if dt is None:
        dt = 1.0
    elif dt <= 0:
        raise ValueError("dt must be positive")
    if nperseg is None:
        nperseg = min(len(data_series) // 2, 10**4)
    elif nperseg > len(data_series):
        raise ValueError("nperseg cannot exceed data length")

    # Compute PSD using Welch's method
    freqs, psd = signal.welch(data_series, fs=1 / dt, nperseg=nperseg)
    freqs = 2 * np.pi * freqs  # Convert to angular frequency (rad/s)

    taud, fitted_lambda = DurationTimeEstimator("acf", "two_sided").estimate_duration_time(data_series, dt, nperseg, cutoff_freq)

    # Plotting
    if ax is not None:
        # Ensure ax is a valid Matplotlib Axes
        if not isinstance(ax, plt.Axes):
            raise ValueError("ax must be a matplotlib.axes.Axes object")

        # Plot data and fit
        line = ax.plot(freqs, psd)
        label = (rf"$\tau_d = {taud:.2g}\, \lambda = {fitted_lambda:.2g}$",)
        ax.plot(
            freqs,
            ce.psd(freqs, taud, fitted_lambda),
            ls="--",
            label=label,
            color=line[0].get_color(),
        )

        y_max = max(np.max(psd), np.max(ce.psd(freqs, taud, fitted_lambda)))
        ax.vlines(cutoff_freq, ymin=0, ymax=y_max, color="black", linestyle="--")

        ax.set_xscale("log")
        ax.set_yscale("log")
        ax.set_xlabel("Angular Frequency (rad/s)")
        ax.set_ylabel("Power Spectral Density")
        ax.set_xlim(min(freqs), max(freqs))
        ax.legend()

    return taud, fitted_lambda, freqs
