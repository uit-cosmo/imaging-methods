import numpy as np
from scipy import signal
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import closedexpressions as ce
import warnings


def fit_psd(data_series, dt=None, nperseg=None, cutoff_freq=1e8, ax=None):
    """
    Compute the power spectral density (PSD) of a data series using Welch's method,
    fit an analytical model derived from a Filtered Poisson Process (FPP) with
    two-sided exponential pulses, and optionally plot results.

    The analytical model for the PSD is:

    .. math::
        S(\omega) = \frac{2 \tau_d}{(1 + (1 - \lambda)^2 (\tau_d \omega)^2)(1 + (\lambda \tau_d \omega)^2)}

    where :math:`\omega` is the angular frequency (rad/s), :math:`\tau_d` is the duration time
    parameter, and :math:`\lambda \in [0, 1]` is the pulse function assymetry parameter.
    This model arises from the FPP model, where the signal is
    generated by a Poisson process filtered with two-sided exponential pulses, resulting
    in a Lorentzian-like PSD with two characteristic timescales.

    Parameters:
    -----------
    data_series : array-like
        Input time series data (1D).
    dt : float, optional
        Time step of the data series. If None, assumed to be 1.
    nperseg : int, optional
        Number of points per segment for Welch's method. If None, set to min(len(data_series) // 2, 10**4).
    cutoff_freq : float, optional
        Frequency cutoff for fitting (default: 1e8 rad/s).
    ax : matplotlib.axes.Axes, optional
        Axes object for plotting. If None, no plot is generated.

    Returns:
    --------
    taud : float
        Fitted decay time parameter.
    lam : float
        Fitted lambda parameter (in [0, 1]).
    """
    # Input validation
    data_series = np.asarray(data_series)
    if data_series.ndim != 1 or len(data_series) < 2:
        raise ValueError("data_series must be a 1D array with at least 2 points")
    if dt is None:
        dt = 1.0
    elif dt <= 0:
        raise ValueError("dt must be positive")
    if nperseg is None:
        nperseg = min(len(data_series) // 2, 10**4)
    elif nperseg > len(data_series):
        raise ValueError("nperseg cannot exceed data length")

    # Compute PSD using Welch's method
    freqs, psd = signal.welch(data_series, fs=1 / dt, nperseg=nperseg)
    freqs = 2 * np.pi * freqs  # Convert to angular frequency (rad/s)

    # Error function for optimization
    def get_error_pdf_fit(params, expected):
        mask = freqs < cutoff_freq
        if not np.any(mask):
            raise ValueError("No frequencies below cutoff_freq")
        lam = 1 / (1 + params[1] ** 2)
        return np.sum((ce.psd(freqs[mask], params[0], lam) - expected[mask]) ** 2)

    # Optimization with bounds
    bounds = [(1e-10, None), (0, None)]  # taud > 0, lamda >= 0
    result = minimize(
        lambda params: get_error_pdf_fit(params, psd),
        x0=[1e-5, 1],
        method="Nelder-Mead",
        bounds=bounds,
        options={"maxiter": 1000},
    )

    # Check optimization convergence
    if not result.success:
        warnings.warn(f"Optimization did not converge: {result.message}")

    taud, lamda = result.x
    fitted_lambda = 1 / (1 + lamda**2)

    # Plotting
    if ax is not None:
        # Ensure ax is a valid Matplotlib Axes
        if not isinstance(ax, plt.Axes):
            raise ValueError("ax must be a matplotlib.axes.Axes object")

        # Plot data and fit
        ax.plot(freqs, psd, label="Data")
        ax.plot(freqs, ce.psd(freqs, taud, fitted_lambda), ls="--", label="Fit")

        # Add text annotations in a legend-like box
        ax.text(
            0.05,
            0.15,
            rf"$\tau_d = {taud:.2g}\, \lambda = {fitted_lambda:.2g}$",
            transform=ax.transAxes,
            fontsize=10,
            verticalalignment="top",
            bbox=dict(facecolor="white", alpha=0.7, edgecolor="black"),
        )

        ax.set_xscale("log")
        ax.set_yscale("log")
        ax.set_xlabel("Angular Frequency (rad/s)")
        ax.set_ylabel("Power Spectral Density")
        ax.set_xlim(min(freqs), max(freqs))
        ax.legend()

    return taud, fitted_lambda
